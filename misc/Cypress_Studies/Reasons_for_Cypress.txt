Pros

1. Instead of using promise based code for testing, Cypress looks much neater -
as a lot of implementation details of applying promises are hidden.
2. A lot of the code is more human readability for testability purposes
3. What makes Cypress unique from other testing tools is that
commands automatically retry their assertions. In fact, they
will look “downstream” at what you’re expressing and modify
their behavior to make your assertions pass.

You should think of assertions as guards.

Use your guards to describe what your application should
look like, and Cypress will automatically block, wait, and
retry until it reaches that state.


Cons

1. Code must idempotent - the code must be retry safe
2. There is a performance tradeoff here: tests that have longer timeout periods
take longer to fail.

Grey Area

1. Cypress cannot yield you primitive values isolated away from other
commands. That is because Cypress commands act internally like an
asynchronous stream of data that only resolve after being affected
and modified by other commands. This means we cannot yield you
discrete values in chunks because we have to know everything about
what you expect before handing off a value.

These design patterns ensure we can create deterministic,
repeatable, consistent tests that are flake free.
